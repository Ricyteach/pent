.. pent mini-language grammar

pent Mini-Language Grammar
==========================

The hierarchical, possibly repeating, structure of data to be parsed by ``pent`` is
represented across multiple levels when constructing a |Parser|.
The core structural element of data is taken to be a single line in the data,
which maps to a ``pent`` "pattern". Each pattern is a string composed of zero or more
space-separated "tokens", describing the content that is expected on that line,
and the subset of content that should be captured by the |Parser| for output.

The patterns are then packaged into a ``pent`` |Parser|,
which is responsible for automatic generation of the regular expressions suitable
for actually parsing and capturing the data.  |Parser|\ s are
constructed at minimum with a `body`, and optionally with a `head` and/or `tail`.
When defined, all three of these can be any of:

   * A single pattern string, matching exactly one line
   * An ordered iterable of pattern strings, matching a number of
     consecutive lines equal to the length of the iterable
   * A |Parser| instance

The regex generated by a |Parser| searches for the following pattern::

    [head](body)+[tail]

In other words, it matches `head` once, if defined; then `body` one or more
times; then `tail` once, if defined. This matching behavior holds **regardless**
of the types of `head`/`body`/`tail`: e.g., if `body` is set to a |Parser|,
that internal |Parser| will be matched one or more times.

A formal grammar for the patterns and tokens is given below. Example data
and |Parser|\ s to import them can be found **[at this as-yet-nonexistent page]**.

Some brief comments first:

 * A pattern string **can** be empty, which matches a line either containing
   nothing, or only whitespace.

 * All patterns ignore leading/trailing whitespace when matching data lines.

 * The first token can be |cour|\ "?"\ |/cour|\ , marking the line as
   OPTIONAL in the pattern. **THIS DOESN'T ALWAYS WORK**--it appears to
   depend on some temperamental quirks of Python's regex engine.

 * Literal, misc and number tokens default to required whitespace after their
   matches in the data; this behavior can be changed by specifying a
   `space_after` flag in the token.

 * Whereas |cour|\ literal_token\ |/cour|\ s with
   |cour|\ match_one_or_more\ |/cour| quantity **DO NOT** interpose whitespace
   between repetions of |cour|\ literal_content\ |/cour| when matching,
   |cour|\ misc_token\ |/cour|\ s and |cour|\ number_token\ |/cour|\ s with
   |cour|\ match_one_or_more\ |/cour| quantity **DO** interpose whitespace
   between sequential miscellaneous and numeric "words", respectively.

 * BEWARE of using too many |cour|\ any_token\ |/cour|\ s, as it can lead
   to regexes with prohibitively long parsing times.

 * SIMILARLY, nesting |Parser|\ s more than one level deep (e.g., much more than
   an outer |Parser| holding an inner |Parser| in `body`) can lead to
   prohibitively slow regexes.


Grammar
-------

Pattern::

    pattern                 ::=  [(optional_line_token )][(content_token )+]


Token::

    optional_line_token     ::=  "?"
    content_token           ::=  any_token | literal_token | misc_token | number_token

    any_token               ::=  "~"[capture]
    literal_token           ::=  "@"[space_after][capture](quantity)(literal_content)
    misc_token              ::=  "&"[space_after][capture](quantity)
    number_token            ::=  "#"[space_after][capture](quantity)(sign)(num_type)

    space_after             ::=  optional_space_after | no_space_after
    optional_space_after    ::=  "o"
    no_space_after          ::=  "x"

    capture                 ::=  "!"

    quantity                ::=  match_one | match_one_or_more
    match_one               ::=  "."
    match_one_or_more       ::=  "+"

    sign                    ::=  any_sign | positive_sign | negative_sign
    any_sign                ::=  "."
    positive_sign           ::=  "+"
    negative_sign           ::=  "-"

    num_type                ::=  integer | float | sci_not | decimal | general
    integer                 ::=  "i"
    float                   ::=  "f"
    sci_not                 ::=  "s"
    decimal                 ::=  "d"
    general                 ::=  "g"


Token Examples:

 * |cour|\ &.\ |/cour| -- Matches a single "word" of arbitrary content, with
   a following space. Whether a preceding space is required depends on the
   |cour|\ space_after\ |/cour| flag of the preceding token.

 * |cour|\ &!.\ |/cour| -- Same as the above, but marks the matched "word" for
   capture into the |Parser| output.

 * |cour|\ "@.Multiple words"\ |/cour| -- Matches the literal string
   |cour|\ Multiple words\ |/cour| exactly once, with a required following space.
   The enclosing quotes are needed if the literal to be matched contains
   whitespace; otherwise they can be omitted.

 * |cour|\ @x+-\ |/cour| -- Matches a sequence of one or more contigous hyphens,
   WITHOUT a following space.

 * |cour|\ #!+.i\ |/cour| -- Matches a series of one or more whitespace-separated
   integers of any sign, with required whitespace following the last integer,
   and marks them for capture into |Parser| output.
